# Relative paths to reduce duplication throughout this file
HPPS=hpps
RTPS=rtps
RTPS_R52=$(RTPS)/r52
RTPS_A53=$(RTPS)/a53
HPPS_ATF=$(HPPS)/arm-trusted-firmware
HPPS_UBOOT=$(HPPS)/u-boot
HPPS_LINUX=$(HPPS)/linux
HPPS_LINUX_BOOT=$(HPPS_LINUX)/arch/arm64/boot
HPPS_BUSYBOX=$(HPPS)/userspace/busybox
RTPS_R52_UBOOT=$(RTPS_R52)/u-boot
RTPS_A53_UBOOT=$(RTPS_A53)/u-boot
RTPS_A53_ATF=$(RTPS_A53)/arm-trusted-firmware
BARE_METAL=hpsc-baremetal

# Revisit: there must not be upward relative paths here. We need to
# be able to build the SSW source tree no matter where it is located.
# This means we need to support pointing to SDK: either to an installed SDK
# (installed by the standalone binary installer), OR build in place:
SDK=../sdk
#
# The above implies that SDK needs to install source of the Qemu device tree
# (which is reasonable); we could also switch to binary overlays but to write
# the overlay, you need the source of the original, so there's little point.
QEMU_DT=$(SDK)/qemu-devicetrees
#
# Revisit: same as above applies, but furthermore, hpsc-utils needs to
# be split. It cannot be simply moved into the SDK as is, because it
# contains makefiles for target software (this makefile), and makefiles for the
# target software cannot be part of the SDK.
# host/ needs to move to SDK; conf/ and make/ needs to move to a repo
# that holds target software (this could be simply a new repo, or it
# could be a parent repo for target software, which would also have submodule
# references)
HPSC_UTILS=../hpsc-utils
TOOLS=$(HPSC_UTILS)/sdk/host
CONF=$(HPSC_UTILS)/conf

CONF_ZEBU=$(CONF)/zebu/hpps
CONF_PROF=$(CONF)/prof
CONF_BASE=$(CONF)/base

# Directory for artifacts created by this top-level build
BLD=bld
BLD_PROF=$(BLD)/prof
BLD_ZEBU=$(BLD)/zebu

UBOOT_TOOLS=$(HPPS_UBOOT)/tools

# Toolchain for bare-metal. Ok if does not support for userspace, e.g.
# aarch64-linux- from pre-built toolchains distributed at kernel.org
CROSS_A53=aarch64-linux-gnu-
# Toolchain for Linux userspace
CROSS_A53_LINUX=aarch64-linux-gnu-
CROSS_R52=arm-none-eabi-
CROSS_M4=arm-none-eabi-

# Settings for build artifacts produced by this top-level builder
HPPS_KERN_LOAD_ADDR=0x8068_0000 # (base + TEXT_OFFSET), where base must be aligned to 2MB
HPPS_DRAM_ADDR=0x8000_0000
HPPS_UBOOT_ENV_SIZE=0x1000 # must match CONFIG_ENV_SIZE in u-boot config

HPPS_ZEBU_DDR_IMAGE_INDEXES=0 1
HPPS_ZEBU_DDR_IMAGES=$(BLD_ZEBU)/hpps/ddr0.bin $(BLD_ZEBU)/hpps/ddr1.bin

# Address parsing function, takes addresses with _ separators
addr=$(subst _,,$1)

# Shortcut aliases
#
# Note: all clean targets here are hardest cleans, and all builds are full,
# e.g. including regeneration of config, if you want any other clean or partial
# build, then use the build system of the respective component directly.

all: trch rtps hpps
clean: trch-clean rtps-clean hpps-clean
.PHONY: all clean

trch: trch-bm syscfg
trch-clean: trch-bm-clean syscfg-clean
.PHONY: trch trch-clean syscfg-clean

rtps: rtps-r52 rtps-a53 rtps-bm
rtps-clean: rtps-r52-clean rtps-a53-clean rtps-r52-bm-clean
.PHONY: rtps rtps-clean

hpps: hpps-atf hpps-uboot hpps-linux hpps-initramfs
hpps-clean: hpps-atf-clean hpps-uboot-clean hpps-linux-clean \
	hpps-busybox-clean hpps-initramfs-clean
.PHONY: hpps hpps-clean

rtps-r52: rtps-r52-uboot rtps-r52-bm
rtps-r52-clean: rtps-r52-uboot-clean rtps-r52-bm-clean
.PHONY: rtps-r52 rtps-r52-clean

rtps-a53: rtps-a53-atf rtps-a53-uboot
rtps-a53-clean: rtps-atf-clean rtps-a53-uboot-clean
.PHONY: rtps-a53 rtps-a53-clean

bm: trch-bm rtps-r52-bm
bm-clean: trch-bm-clean rtps-r52-bm-clean
.PHONY: bm bm-clean

$(BLD)/%/:
	mkdir -p "$@"
.PRECIOUS: $(BLD)/%/

# Invariant: artifacts have a unique recipe. That unique recipe may part of two
# different dependency trees: (A) the dependency tree for the user interface
# target (aka. an alias), or (B) the dependency tree of another artifact (e.g.
# a memory image). Also we have the requirement that rule for nested artifacts
# trigger the nested dependency build. This won't happen if the rule here
# depends on the artifact (the dep tree would be truncated at that artifact --
# if it exists, no recipe will be invoked, even if its dependencies in the
# nested tree are stale).
#
# This invariant plus the requirements determines the pattern: the recipe for
# invoking the nested dependency building for a nested artifact is associated
# with a phony target. Then, both the user-facing alias (case A) and the
# artifact (case B) both depend on that phony target. Most often there's no
# alias (case A) because the phony target is short enough to be user-facing.
#
# Another non-way to satisfy invariant+requirement would be to use only the
# phony targets for the artifacts here (i.e. eliminate Case B rule), but this
# hinders rule legibility because dependencies can no longer be explicit
# artifacts (they are phony targets) and the recipies can no longer refer to
# dependencies (e.g. via $<).

TRCH_BM_ARGS=
$(BARE_METAL)/trch/bld/trch.elf: trch-bm
trch-bm:
	$(MAKE) -C $(BARE_METAL)/trch$(TRCH_BM_ARGS) CROSS_COMPILE=$(CROSS_M4)
trch-bm-clean:
	$(MAKE) -C $(BARE_METAL)/trch$(TRCH_BM_ARGS) clean
.PHONY: trch-bm trch-bm-clean

RTPS_R52_BM_ARGS=
$(BARE_METAL)/rtps/bld/rtps.uimg: rtps-bm
rtps-r52-bm:
	$(MAKE) -C $(BARE_METAL)/rtps $(RTPS_R52_BM_ARGS) CROSS_COMPILE=$(CROSS_R52)
rtps-r52-bm-clean:
	$(MAKE) -C $(BARE_METAL)/rtps $(RTPS_R52_BM_ARGS) clean
.PHONY: rtps-r52-bm rtps-r52-bm-clean

RTPS_R52_UBOOT_ARGS=CROSS_COMPILE=$(CROSS_R52)
$(RTPS_R52_UBOOT)/.config: $(RTPS_R52_UBOOT)/configs/hpsc_rtps_r52_defconfig
	$(MAKE) -C $(RTPS_R52_UBOOT) $(RTPS_R52_UBOOT_ARGS) hpsc_rtps_r52_defconfig
$(RTPS_R52_UBOOT)/u-boot.bin: $(RTPS_R52_UBOOT)/.config
	$(MAKE) -C $(RTPS_R52_UBOOT) $(RTPS_R52_UBOOT_ARGS) u-boot.bin
rtps-r52-uboot:
	$(MAKE) -C $(RTPS_R52_UBOOT) $(RTPS_R52_UBOOT_ARGS)
rtps-r52-uboot-clean:
	$(MAKE) -C $(RTPS_R52_UBOOT) $(RTPS_R52_UBOOT_ARGS) clean
	rm -f $(RTPS_R52_UBOOT)/.config
.PHONY: rtps-r52-uboot rtps-r52-uboot-clean

RTPS_A53_UBOOT_ARGS=CROSS_COMPILE=$(CROSS_A53)
$(RTPS_A53_UBOOT)/.config: $(RTPS_A53_UBOOT)/configs/hpsc_rtps_a53_defconfig
	$(MAKE) -C $(RTPS_A53_UBOOT) $(RTPS_A53_UBOOT_ARGS) hpsc_rtps_a53_defconfig
$(RTPS_A53_UBOOT)/u-boot.bin: $(RTPS_A53_UBOOT)/u-boot.bin
	$(MAKE) -C $(RTPS_A53_UBOOT) $(RTPS_A53_UBOOT_ARGS) u-boot.bin
rtps-a53-uboot:
	$(MAKE) -C $(RTPS_A53_UBOOT) $(RTPS_A53_UBOOT_ARGS)
rtps-a53-uboot-clean:
	$(MAKE) -C $(RTPS_A53_UBOOT) $(RTPS_A53_UBOOT_ARGS) clean
	rm -f $(RTPS_A53_UBOOT)/.config
.PHONY: rtps-a53-uboot rtps-a53-uboot-clean

RTPS_A53_ATF_ARGS=PLAT=hpsc_rtps_a53 DEBUG=1 CROSS_COMPILE=$(CROSS_A53)
$(RTPS_A53_ATF)/build/hpsc_rtps_a53/debug/bl31.bin:
	$(MAKE) -C $(RTPS_A53_ATF) $(RTPS_A53_ATF_ARGS) bl31
rtps-a53-atf:
	$(MAKE) -C $(RTPS_A53_ATF) $(RTPS_A53_ATF_ARGS) bl31
rtps-a53-atf-clean:
	$(MAKE) -C $(RTPS_A53_ATF) $(RTPS_A53_ATF_ARGS) clean
.PHONY: rtps-a53-atf rtps-a53-atf-clean

HPPS_ATF_ARGS=PLAT=hpsc DEBUG=1 CROSS_COMPILE=$(CROSS_A53)
$(HPPS_ATF)/build/hpsc/debug/bl31.bin:
	$(MAKE) -C $(HPPS_ATF) $(HPPS_ATF_ARGS) bl31
hpps-atf:
	$(MAKE) -C $(HPPS_ATF) $(HPPS_ATF_ARGS) bl31
hpps-atf-clean:
	$(MAKE) -C $(HPPS_ATF) $(HPPS_ATF_ARGS) clean
.PHONY: hpps-atf hpps-atf-clean

HPPS_UBOOT_ARGS=CROSS_COMPILE=$(CROSS_A53)
$(HPPS_UBOOT)/.config: $(HPPS_UBOOT)/configs/hpsc_hpps_defconfig
	$(MAKE) -C $(HPPS_UBOOT) $(HPPS_UBOOT_ARGS) hpsc_hpps_defconfig
$(HPPS_UBOOT)/u-boot.bin: $(HPPS_UBOOT)/.config
	$(MAKE) -C $(HPPS_UBOOT) $(HPPS_UBOOT_ARGS) u-boot.bin
$(HPPS_UBOOT)/u-boot.dtb: $(HPPS_UBOOT)/u-boot.bin
	$(MAKE) -C $(HPPS_UBOOT) $(HPPS_UBOOT_ARGS) u-boot.dtb
$(HPPS_UBOOT)/tools/mkenvimage:
	$(MAKE) -C $(HPPS_UBOOT) $(HPPS_UBOOT_ARGS) tools
hpps-uboot-clean:
	$(MAKE) -C $(HPPS_UBOOT) $(HPPS_UBOOT_ARGS) clean
	rm -f $(HPPS_UBOOT)/.config
hpps-uboot: $(HPPS_UBOOT)/.config
	$(MAKE) -C $(HPPS_UBOOT) $(HPPS_UBOOT_ARGS)
.PHONY: hpps-uboot hpps-uboot-clean

HPPS_LINUX_ARGS=ARCH=arm64 CROSS_COMPILE=$(CROSS_A53)
$(HPPS_LINUX)/.config: $(HPPS_LINUX)/arch/arm64/configs/hpsc_defconfig
	$(MAKE) -C $(HPPS_LINUX) $(HPPS_LINUX_ARGS) hpsc_defconfig

$(HPPS_LINUX_BOOT)/Image: $(HPPS_LINUX)/.config
	$(MAKE) -C $(HPPS_LINUX) $(HPPS_LINUX_ARGS) Image

# Note: need to sequence, otherwise whether we have two targets at same
# priority or we have one recipe with multiple artifacts, in both cases will be
# broken with parallel make. We do want explicit references to both artifacts
# in this makefile though, because they both participate in images.
$(HPPS_LINUX_BOOT)/dts/hpsc/hpsc.dtb: $(HPPS_LINUX_BOOT)/Image.gz
	$(MAKE) -C $(HPPS_LINUX) $(HPPS_LINUX_ARGS) hpsc/hpsc.dtb

$(BLD)/hpps/uImage: $(HPPS_LINUX_BOOT)/Image.gz | $(BLD)/hpps/ $(UBOOT_TOOLS)/mkimage
	$(UBOOT_TOOLS)/mkimage -T kernel -C gzip -A arm64 -d "$<" \
		-a $(call addr,${HPPS_KERN_LOAD_ADDR}) "$@"

# The make command in this recipe is only used for the invocation from the user
# interface (via hpps-linux phony target shortcut), but not from the dependency
# build of another artifact, for which the above recipes are used (a violation
# of the invariant above). The non-phony rules (above) define a shallow
# dependency graph which is disconnected from the nested dependency graph
# (modifying kernel.c will not cause uImage to be remade).  Hence, the phony
# target (hpps-linux) below gives the user a convenience way to force the
# nested dependency build.
#
# The implementation of this conenience must not allow the nested dependency
# build to be invoked concurrently multiple times, because that breaks the
# build (it's in the same directory; even if the root targets of each
# invocation differ, their dependencies may be shared and thus built twice
# concurrently on top of each other).
#
# The non-working approach is a master target that would depend on two targets,
# (1) a target that invokes the nested dependency build (waht hpps-linux does),
# and (2) build uImage (which itself depends on the nested build again). For
# (1) we would want to depend on the phony hpps-linux and not on Image.gz,
# because the latter is shallow. This master target won't work because the
# nested build recipe is present twice in the dependency subgraph of the master
# target, which allows the nested build to be invoked concurrently.
#
# The solution is to sequence the nested builds. This can be done in one
# of two ways: (A) invoke ourselves in the recipe that invokes the nested
# build (after that nested build command); or (B) define a chain of phony
# targets each of which invokes the nested build all are strictly ordered
# (hpps-linux-all -> hpps-linux-img -> hpps-linux). (B) requires having the
# same commands in the phony and non-phony recipe (for the commands that are
# not the nested build commands (e.g. build uImage), which is best done by
# factoring the commands into functions. We choose (A).
hpps-linux: $(HPPS_LINUX)/.config
	$(MAKE) -C $(HPPS_LINUX) $(HPPS_LINUX_ARGS)
	$(MAKE) $(BLD)/hpps/uImage
hpps-linux-clean:
	$(MAKE) -C $(HPPS_LINUX) $(HPPS_LINUX_ARGS) mrproper
	rm -f $(BLD)/hpps/uImage
.PHONY: hpps-linux hpps-linux-clean


HPPS_BUSYBOX_ARGS=CROSS_COMPILE=$(CROSS_A53_LINUX)
$(HPPS_BUSYBOX)/.config: $(CONF_BASE)/hpps/busybox/hpsc_hpps_miniconf
	$(MAKE) -C $(HPPS_BUSYBOX) $(HPPS_BUSYBOX_ARGS) \
		allnoconfig KCONFIG_ALLCONFIG="$(abspath $<)"
$(HPPS_BUSYBOX)/busybox: $(HPPS_BUSYBOX)/.config
	$(MAKE) -C $(HPPS_BUSYBOX) $(HPPS_BUSYBOX_ARGS) busybox
hpps-busybox: $(HPPS_BUSYBOX)/.config
	$(MAKE) -C $(HPPS_BUSYBOX) $(HPPS_BUSYBOX_ARGS)
hpps-busybox-clean:
	$(MAKE) -C $(HPPS_BUSYBOX) $(HPPS_BUSYBOX_ARGS) clean
	rm -f $(HPPS_BUSYBOX)/.config
.PHONY: hpps-busybox hpps-busybox-clean

# Targets that implement profiles (generic across profile)

PROFILES=$(notdir $(wildcard $(CONF_PROF)/*))

# Artifacts generated for all profiles
PROF_COMMON=\
	qemu/prof.qemu-env.sh \
	qemu/prof.qemu.dtb \
	qemu/prof.preload.mem.map \
	trch/prof.syscfg.bin \
	trch/prof.sram.mem.bin \
	hpps/prof.hpps-uboot.env.bin \
	hpps/initramfs.uimg \

define prof-common
$(patsubst %,$(BLD_PROF)/$(1)/%,$(PROF_COMMON))
endef

# We cannot append deps to pattern rules, so have to use explicit rules.
define merge-base-rules
$(BLD_PROF)/$(1)/%: export PROF=$(1)
prof-$(1): $(call prof-common,$(1))
$(BLD_PROF)/$(1)/qemu/prof.qemu-env.sh: $(CONF_BASE)/qemu/qemu-env.sh | $(BLD_PROF)/$(1)/qemu/
$(BLD_PROF)/$(1)/qemu/prof.qemu.dts: $(QEMU_DT)/hpsc-arch.dts | $(BLD_PROF)/$(1)/qemu/
$(BLD_PROF)/$(1)/qemu/prof.preload.mem.map: $(CONF_BASE)/qemu/preload.mem.map | $(BLD_PROF)/$(1)/qemu/
$(BLD_PROF)/$(1)/trch/prof.syscfg.ini: $(CONF_BASE)/trch/syscfg.ini | $(BLD_PROF)/$(1)/trch/
$(BLD_PROF)/$(1)/trch/prof.sram.mem.map: $(CONF_BASE)/trch/sram.mem.map | $(BLD_PROF)/$(1)/trch/
$(BLD_PROF)/$(1)/hpps/prof.hpps-uboot.env: $(CONF_BASE)/hpps/u-boot/uboot.env | $(BLD_PROF)/$(1)/hpps/
$(BLD_PROF)/$(1)/hpps/prof.hpps-uboot.dts: $(HPPS_UBOOT)/arch/arm/dts/hpsc-hpps.dts | $(BLD_PROF)/$(1)/hpps/
$(BLD_PROF)/$(1)/hpps/prof.hpps-linux.dts: $(HPPS_LINUX_BOOT)/dts/hpsc/hpsc.dts | $(BLD_PROF)/$(1)/hpps/
$(BLD_PROF)/$(1)/zebu/prof.hpps.dram.mem.map: $(CONF_BASE)/zebu/hpps-mem.map | $(BLD_PROF)/$(1)/zebu/
endef
$(foreach prof,$(PROFILES),$(eval $(call merge-base-rules,$(prof))))

include $(CONF_PROF)/*/Makefile.prof # definitions of profiles

.PHONY: prof-%

prof-%-clean:
	rm -rf $(BLD_PROF)/$*/
.PHONY: prof-%-clean

# Merging rules. Each profile defines the inputs to merge as dependencies.

$(BLD_PROF)/%.dts $(BLD_PROF)/%.sh:
	cat $(INPUTS) $^ > $@

$(BLD_PROF)/%.ini:
	$(TOOLS)/merge-ini $(INPUTS) $^ > $@

$(BLD_PROF)/%.env:
	$(TOOLS)/merge-env $(INPUTS) $^ > $@

$(BLD_PROF)/%.mem.map:
	$(TOOLS)/merge-map $(INTPUTS) $^ > $@

IRF_FR=initramfs.fakeroot
$(BLD_PROF)/%/hpps/initramfs.cpio: $(wildcard \
	$(CONF_BASE)/hpps/initramfs/* $(CONF_BASE)/hpps/initramfs/*/*  \
	$(CONF_PROF)/%/hpps/initrams/* $(CONF_PROF)/%/hpps/initrams/*/*) \
	$(HPPS_BUSYBOX)/busybox | $(BLD_PROF)/%/hpps/
	rsync -aq $(CONF_BASE)/hpps/initramfs/ $(@D)/initramfs
	[ ! -d "$(CONF_PROF)/$*/hpps/initramfs/" ] || \
		rsync -aq $(CONF_PROF)/$*/hpps/initramfs/ $(@D)/initramfs
	( cd $(@D)/initramfs && fakeroot -s ../$(IRF_FR) $(abspath $(CONF_BASE)/hpps/initramfs.sh) )
	[ ! -f "$(CONF_PROF)/$*/hpps/initramfs.sh" ] || \
		( cd $(@D)/initramfs && fakeroot -s ../$(IRF_FR) $(abspath $(CONF_PROF)/$*/hpps/initramfs.sh) )
	fakeroot -i $(@D)/$(IRF_FR) -s $(@D)/$(IRF_FR) \
		$(MAKE) -j1 -C $(HPPS_BUSYBOX) $(HPPS_BUSYBOX_ARGS) \
			CONFIG_PREFIX="$(abspath $(@D)/initramfs)" install
	fakeroot -i $(@D)/$(IRF_FR) -s $(@D)/$(IRF_FR) \
		$(MAKE) -C $(HPPS_LINUX) $(HPPS_LINUX_ARGS) \
			INSTALL_MOD_PATH=$(abspath $(@D)/initramfs) modules_install
	cd $(@D)/initramfs && find . | fakeroot -i ../$(IRF_FR) -s $(IRF_FR) \
		cpio -R root:root -c -o -O "../$(@F)"

# Could use the generic target, but then need names *.hpps-initramfs.*
$(BLD_PROF)/%/hpps/initramfs.uimg: $(BLD_PROF)/%/hpps/initramfs.cpio.gz
	$(UBOOT_TOOLS)/mkimage -T ramdisk -C gzip -A arm64 -n "Initramfs" -d "$<" "$@"

# Note the empty recipe, because it's an alias that is a pattern rule
prof-%-hpps-initramfs: $(BLD_PROF)/%/hpps/initramfs.uimg
	
prof-%-hpps-initramfs-clean:
	rm -rf $(BLD_PROF)/$*/hpps/initramfs{/,.uimg,.cpio,.cpio.gz,.fakeroot}
.PHONY: prof-%-hpps-initramfs prof-%-hpps-initramfs-clean

# Memory images

ifeq ($(filter %-clean,$(MAKECMDGOALS)),)
-include $(foreach prof,$(PROFILES),\
		$(BLD_PROF)/$(prof)/trch/prof.sram.mem.rule)
endif

# Zebu targets

# Note the empty recipe. Not sure why it does not work without it.
prof-%-zebu-hpps: $(BLD_PROF)/%/zebu/prof.hpps.dram.mem.bin
# Enable the following to also generate striped images (.bin or .vhex)
# prof-%-zebu-hpps: $(BLD_PROF)/%/zebu/prof.hpps.zebu.x.ddr.bin
	
.PHONY: prof-%-zebu-hpps
prof-%-zebu-hpps-clean:
	rm -rf $(BLD_PROF)/$*/zebu/prof.hpps.dram.mem.{bin,dep,rule} \
		$(BLD_PROF)/$*/zebu/hpps.zebu.*.ddr.bin
.PHONY: prof-%-zebu-hpps prof-%-zebu-hpps-clean

ifeq ($(filter %-clean,$(MAKECMDGOALS)),)
ifneq ($(findstring zebu,$(MAKECMDGOALS)),)
-include $(foreach prof,$(PROFILES_WITH_ZEBU),\
		$(BLD_PROF)/$(prof)/zebu/prof.hpps.zebu.mem.rule)
endif
endif

# Extract dependencies from a memory map file into a rule file
%.mem.dep: %.mem.map
	$(TOOLS)/mkmemimg -l $< > $@

%.mem.rule: %.mem.dep
	sed 's#^#$(patsubst %.rule,%.bin,$@): #' $< > $@

%.sram.mem.bin: TYPE=sram
%.dram.mem.bin: TYPE=dram

%.mem.bin: %.mem.map
	$(TOOLS)/mkmemimg -t $(TYPE) $< $@

# The touch is a workaround for .INTERMEDIATE not accepting patterns,
# otherwise, we would mark the master target intermediate without a real file.
define zebu-stripe-ddr
	$(TOOLS)/memstripe --base $(1) -i $< \
		$(foreach idx,$(2),$(patsubst %.x.ddr.bin,%.$(idx).ddr.bin,$@))
	touch $@
endef

# Note the empty recipe. Not sure why it doesn't work without it, but
# it has to do with the pattern, because without a pattern, it works
define zebu-ddr-rule
%.$(1).zebu.$(2).ddr.bin: %.$(1).zebu.x.ddr.bin
	
endef

%.hpps.zebu.x.ddr.bin: %.hpps.dram.mem.bin
	$(call zebu-stripe-ddr,$(HPPS_DRAM_ADDR),$(HPPS_ZEBU_DDR_IMAGE_INDEXES))
#.INTERMEDIATE: %.hpps.zebu.x.ddr.bin # patterns do not work here (use touch+PRECIOUS)
.PRECIOUS: %.hpps.zebu.x.ddr.bin
$(foreach idx,$(HPPS_ZEBU_DDR_IMAGE_INDEXES),$(eval $(call zebu-ddr-rule,hpps,$(idx))))

%.vhex: %.bin
	$(TOOLS)/hpsc-objcopy -I binary -O Verilog-H $< $@

%.gz: %
	gzip -c -9 "$<" > "$@"

define dt-rule
	$(CC) -E -nostdinc -x assembler-with-cpp $(1) -o - $< | \
		dtc -q -I dts -O dtb -o $@ -
endef

%.qemu.dtb: %.qemu.dts
	$(call dt-rule,-I$(QEMU_DT))

%.hpps-uboot.dtb: %.hpps-uboot.dts
	$(call dt-rule,-I$(HPPS_UBOOT)/arch/arm/dts \
		-I$(HPPS_UBOOT)/arch/arm/dts/include -I$(HPPS_UBOOT)/include)

%.hpps-linux.dtb: %.hpps-linux.dts
	$(call dt-rule,-I$(HPPS_LINUX)/include -I$(HPPS_LINUX_BOOT)/dts/hpsc)

%.dtb: %.dts
	$(call dt-rule,)

define make-uboot-env
	$(UBOOT_TOOLS)/mkenvimage -s $(1) -o $@ $<
endef

%.hpps-uboot.env.bin: %.hpps-uboot.env | $(UBOOT_TOOLS)/mkenvimage
	$(call make-uboot-env,$(HPPS_UBOOT_ENV_SIZE))

%.syscfg.bin: %.syscfg.ini
	$(TOOLS)/cfgc -s ${CONF_BASE}/trch/syscfg-schema.json $< $@

# Prevent deletion of intermediate artifacts
.SECONDARY:
