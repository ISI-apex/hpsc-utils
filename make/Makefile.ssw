## Builds HPSC SW stack with support for configuration variants (profiles)
#
# Quick guide (after the first build, targets will effectively autocomplete):
#
#   List available configuration profiles:
#     $ make
#   Pick a desired profile from the list, say 'hpps-busybox', and build it
#	(invokes nested builds then shallow builds):
#     $ make prof/hpps-busybox
#
#   Run the selected profile in the Qemu emulator
#     $ make prof/hpps-busybox/run/qemu
#   Run the selected profile in the Zebu emulator
#     $ make prof/hpps-busybox/run/zebu
#   Clean run state:
#     $ make prof/hpps-busybox/run/qemu/clean
#
#   Clean a profile (invokes nested builds too, cleans everything):
#     $ make prof/hpps-busybox/clean
#
#   Clean artifacts outside nested source trees (does not invoke nested
#   builds):
#     $ make prof/hpps-busybox/bld/clean
#
#   Re-build a module incrementally (invoke the nested build: only builds
#   the source tree and no other artifacts):
#       $ make prof/hpps-busybox/bld/hpps/linux
#
#   Clean a module (invoke the nested build: only cleans artifacts in source
#   tree):
#       $ make prof/hpps-busybox/bld/hpps/linux/clean
#       $ make prof/hpps-busybox/bld/hpps/rootfs/clean
#
#   Privatize module source directories (make a copy) and build them:
#		$ make PRIV=1 prof/hpps-busybox

# Paths into the configuration profile system
HPSC_UTILS:=hpsc-utils
CONF:=$(HPSC_UTILS)/prof
BIN:=$(HPSC_UTILS)/bin

# Somewhat special profile for configuration for run targets (autoincluded)
CONF_TARGET:=$(CONF)/lib-target

## Cross-compilation toolchains: expected in PATH (by loading the HPSC SDK env)
#
# Toolchain for bare-metal. Ok if does not support for userspace, e.g.
# aarch64-linux- from pre-built toolchains distributed at kernel.org
CROSS_A53=aarch64-linux-gnu-
# Toolchain for Linux userspace
CROSS_A53_LINUX=aarch64-linux-gnu-
CROSS_R52=arm-none-eabi-
CROSS_M4=arm-none-eabi-

## Basic tools that the rules rely on
#
# Command to be used in places where we are ok with just a hard link
COPY=cp -l --remove-destination
RSYNC=rsync

# Directory that holds all output
PROFDIR := prof

# Logic to autodetect profile from target name(s)
#
# Note: multiple targets can be specified, but concurrent build of different
# profiles will succeed only if the set of selected profiles share any nested
# module (unlikely), or if the privatized mode is enabled (PRIV=1).
ifeq ($(PROF),)

# Introspective target for convenience
PROF_GROUPS:=lib tool sys
DESC_lib:="Library overlays to be used in other profiles"
DESC_tool:="Tool profiles used internally to build artifacts"
DESC_sys:="System-wide runnable profiles"
define print-profs
	@echo ### $(2):
	@find $(CONF) -mindepth 1 -maxdepth 1 -type d -name '$(1)-*' \
		-printf '%f\n' -exec sed '/^$$/q' {}/Makefile \;
	@echo
endef
list-%: PHONY
	@find $(CONF) -mindepth 1 -maxdepth 1 -type d -name '$*-*' \
		-printf '%f\n' | sort
list:
	@find $(CONF) -mindepth 1 -maxdepth 1 -type d -printf '%f\n' | sort
	@echo "To print details: make desc"
all: list
desc-%: PHONY
	$(call print-profs,$*,$(DESC_$*))
desc:
	$(foreach g,$(PROF_GROUPS),$(call print-profs,$(g),$(DESC_$(g))))
.PHONY: all list desc

PROFS=$(patsubst $(CONF)/%,%,$(wildcard $(CONF)/*))
define prof-rule
$(PROFDIR)/$(1): PHONY
	$$(MAKE) PROF=$(1)
$(PROFDIR)/$(1)/%: PHONY
	$$(MAKE) PROF=$(1) $$@
endef
$(foreach p,$(PROFS),$(eval $(call prof-rule,$(p))))

else # PROF is defined, so eval everything else

# By default the build is conservative (i.e. deep). This top-level build has to
# invoke nested builds of modules since it can't track dependencies into the
# nested source tree; and it has to rebuild derived artifacts whose dependencies
# are also not tracked fully (e.g. .fs directories). Allow the caller
# to request a deep or shallow build for a subset of modules.
#   DEEP=1 means all
#   DEEP=0 means none
#   DEEP="pattern1 pattern2..." means some, with support for % wildcard.
#   SHALLOW= is analogous, takes precedence over DEEP
DEEP ?= %
SHALLOW ?=

# Transforms {0,1,pattern pattern...} into {,%,pattern pattern...}
set-def = $(if $(filter 1,$(words $(1))),\
				  $(if $(filter-out 0,$(1)),\
						$(if $(filter 1,$(1)),%,$(1))),\
				  $(1))

override DEEP := $(call set-def,$(DEEP))
override SHALLOW := $(call set-def,$(SHALLOW))

# Allow the caller to put the privatized sources under its own dir
PROF_HOME ?= $(PROFDIR)/$(PROF)

# Profiles overlays also use these variables
SRCDIR:=src
BLDDIR:=bld
RUNDIR:=run
PROF_BLD:=$(PROF_HOME)/bld
PROF_SRC:=$(PROF_HOME)/$(SRCDIR)
PROF_OK:=$(PROF_HOME)/ok
PROF_RUN:=$(PROF_HOME)/$(RUNDIR)
PROF_PROF:=$(PROF_HOME)/$(PROFDIR)

# Directories with artifacts that should be empied but kept on clean,
# so that "autocomplete" keep working (partially). Rules append, module
# directories themselves added automatically for all modules.
KEEP_DIRS=

all: $(PROF_HOME)
.PHONY: all

$(PROFDIR)/%/:
	mkdir -p "$@"
.PRECIOUS: $(PROFDIR)/%/

## Rules for artifacts produced by this top-level makefile, and not by
# a nested build (excluding some artifacts that are tightly affiliated with a
# nested module and whose rules are given along with module's rules).

# Note: even though some of these rules are generic, at most, we only define
# them for the files in the build directory $(PROF_BLD) in order to avoid dep
# loops created due to attempts to create the missing prerequisites (e.g. due
# to bugs in a profile definition) in the source directory: e.g. if the
# objective is to create a .dir from a .tar.gz, but .tar.gz is missing, make
# would attempt to create the .tar.gz by compressing something. This issue
# can still happen among artifacts within $(PROF_BLD) directory, oh well.

# Artifacts that are merged from overlay declared as prereqs by profiles
#
# Declare these before including the profiles, so that the merge base
# defined here is first in the prereq order.
#
# Note: these play only a minor role: directory creation. As long as the
# profile defines the order-only directory rule, it can introduce whatever
# files it wishes -- files with extensions convered by the merge rules will be
# merged. In favor of brevity of profile overlays, we define most here. Too
# we can't "append" prerequisites using an implicit pattern rule.

KEEP_DIRS += $(PROF_BLD)/trch

KEEP_DIRS += $(PROF_BLD)/hpps
$(PROF_BLD)/hpps/conf.sh: | $(PROF_BLD)/hpps/

# Merging rules. Each profile defines the inputs to merge as dependencies.

# concat(out,in ...,comment_start,comment_end)
define concat
	truncate --size=0 $(1)
	[ -z "$(2)" ] || \
		find $(patsubst %,%\$(NL) ,$(2)) \
			-exec echo -e '\n$(3) ======= MERGED FILE: {} ====== $(4)\n' >> $(1) \; \
				-exec cat {} >> $(1) \;
endef

$(PROF_BLD)/%.dts:
	$(call concat,$@,$^,/*,*/)

$(PROF_BLD)/%.sh $(PROF_BLD)/%.config.mk $(PROF_BLD)/%.conf $(PROF_BLD)/%.miniconf:
	$(call concat,$@,$^,#,)

$(PROF_BLD)/%.ini:
	merge-ini -o $@ $^

$(PROF_BLD)/%.env:
	merge-env -o $@ $^

$(PROF_BLD)/%.mem.map:
	merge-map -o $@ $^

# Not a generic rule because properties differ by target subsystem
$(PROF_BLD)/hpps/initramfs.uimg: $(PROF_BLD)/hpps/initramfs.cpio.gz
	mkimage -T ramdisk -C gzip -A arm64 -n "Initramfs" -d "$<" "$@"

# If you have a rootfs archive, you can always make an initramfs archive
$(PROF_BLD)/%.initramfs.tar.gz: $(PROF_BLD)/%.rootfs.tar.gz
	$(COPY) $< $@

$(PROF_BLD)/hpps/initramfs.fs \
$(PROF_BLD)/hpps/rootfs.fs \
: $(call depth-prereq,PHONY) | $(PROF_BLD)/hpps/

# Rule for composing directory a tree. Components are added as prereqs and can
# be: directories (with or without fakeroot DB) and dir-creator shell scripts.
# Touch needed, because copies don't necessary update dir, but other targets
# (e.g. cpio) need to register that this target changed.
#
# Technically, this could be phony (by adding PHONY to prereq), because there
# is no deep dependency tree for the contents of the folder (would be possible
# to implement, though), so we can't know whether components have changed or
# not. BUT, rebuilding images is expensive, so we don't mark it phony, and rely
# either on explicit rules for specific artifacts (e.g. initramfs.fs) to make
# them phony, or on the user to trigger the clean and rebuild manually when
# desired.
$(PROF_BLD)/%.fs: | $(PROF_BLD)/%.fs/
	truncate --size=0 $@.fr
	find "$@" -mindepth 1 -delete
	$(foreach d,$^,\
		$(if $(filter %.dir,$(d)),\
			$(if $(filter %.fr.dir,$(d)),cat $(d).fr >> $@.fr && \$(NL))\
			fakeroot -i $@.fr -s $@.fr \$(NL) $(RSYNC) -aq $(d)/ $@,\
		$(if $(filter %.dir.sh,$(d)),\
			cd $@ && \$(NL) fakeroot -i ../$(@F).fr -s ../$(@F).fr $(abspath $(d))))\
		$(NL))
	@[ -d "$@" ] || ( echo "ERROR: empty file system: $@" 2>&1 && exit 1 )
	touch $@

# Made by the same rule as %.fs (don't bother tracking dual artifacts, they are
# always used together in prerequisite sets).
$(PROF_BLD)/%.fs.fr: $(PROF_BLD)/%.fs ;

# Extract rules: touch the dir after extracting because tar sets it to some
# date in the archive which makes the output of the rule always stale.

$(PROF_BLD)/%.tar.fr.dir: $(PROF_BLD)/%.tar.gz | $(PROF_BLD)/%.tar.fr.dir/
	rm -rf "$@" && mkdir -p "$@"
	fakeroot -s $@.fr tar -C $@ -x -f $<
	touch $@

$(PROF_BLD)/%.cpio: $(PROF_BLD)/%.fs $(PROF_BLD)/%.fs.fr
	cd $< && find . | fakeroot -i ../$(<F).fr cpio -o -R root:root -H newc -O ../$(@F)

$(PROF_BLD)/%.fs.tar.gz: $(PROF_BLD)/%.fs $(PROF_BLD)/%.fs.fr
	fakeroot -i $<.fr tar -C $< -c -z -f $@ .

$(PROF_BLD)/%.gz: $(PROF_BLD)/%
	gzip -c -9 "$<" > "$@"

$(PROF_BLD)/%.jffs2 : $(PROF_BLD)/%.fs $(PROF_BLD)/%.jffs2.conf.sh
	source $(PROF_BLD)/$*.jffs2.conf.sh && \
		fakeroot -i $<.fr mkfs.jffs2 -n -e $$NAND_ERASE_BLOCK_SIZE_KB -o $@ -r $< && \
		SIZE=$$(stat -c '%s' $@) && \
		truncate --size=$$(((SIZE + NAND_PAGE_SIZE) & ~(NAND_PAGE_SIZE - 1))) $@

# Recipes for building device trees

define dtc-cmd
	$(CC) -E -nostdinc -x assembler-with-cpp $(1) -o - $< | \
		dtc -q -I dts -O dtb -o $@ -
endef

$(PROF_BLD)/%.dtb: $(PROF_BLD)/%.dts
	$(call dtc-cmd,)

$(PROF_BLD)/%.exp.mem.map: $(PROF_BLD)/%.mem.map
	PROF=$(PROF) PROF_HOME=$(PROF_HOME) PROF_BLD=$(PROF_BLD) ROOT=. \
		expandvars -o $@ $<

$(PROF_BLD)/%.sfs.mem.bin: $(PROF_BLD)/%.sfs.exp.mem.map $(PROF_BLD)/%.sfs.ini
	mksfs --tool sram-image-utils -o $@ -c $(PROF_BLD)/$*.sfs.ini $<
	sram-image-utils s $@

# Recipes for building artifacts that involve executing Qemu
#
# These recipes execute Qemu using a dedicated tool profile in privatized mode,
# so that the nested build does not interfere with the current build to which
# the artifact belongs to.

# Create NAND memory image from a tarball archive
#
# Ideally, this would be done using a dedicated tool on the host, but no such
# tool exists and its nontrivial (it is not a matter of mounting a loop device,
# because the image file format is up to Qemu). So, we use Qemu loaded with
# Linux as the tool, and simply write the memory through Linux.
#
# Privatize the sources, so that the build of the tool does not interfere
# with the parent build, also privatze into a subdirectory of the parent,
# so that the tool builds of two different parents don't interfere.
NAND_WR_PROF:=tool-nand-writer
NAND_WR_HOME:=$(PROF_PROF)/$(NAND_WR_PROF)
# Must match name in profile overlay (could use env var, but this seems clearer)
NAND_WR_IN:=$(NAND_WR_HOME)/input.tar.gz
NAND_WR_OUT:=$(NAND_WR_HOME)/$(RUNDIR)/qemu/hpps.smc.nand.0.mem.nand.bin
# The profile must add the source as a prereq (rootfs.tar.nand.bin or other)
$(PROF_BLD)/hpps/prof.rootfs.nand.bin: | $(PROF_BLD)/hpps/
	@[ ! -z "$^" ] || ( echo "ERROR: no source prereq for: $@" 2>&1 && exit 1 )
	$(COPY) $< $@
$(PROF_BLD)/hpps/rootfs.nand.bin: $(PROF_BLD)/hpps/rootfs.jffs2 \
								  | $(PROF_BLD)/hpps/ $(NAND_WR_HOME)/
	$(COPY) $< $(NAND_WR_IN)
	CONF=$(CONF) source $(CONF)/$(NAND_WR_PROF)/conf.sh && \
		qmp-mem-wait -p $$(ps -o ppid= $$$$) \
			localhost $$QMP_PORT $$DONE_CPU $$DONE_ADDR $$DONE_PATTERN \
			qmp.py localhost $$QMP_PORT quit & \
		$(MAKE) PROF=$(NAND_WR_PROF) PRIV=1 PROF_HOME=$(NAND_WR_HOME) \
			$(NAND_WR_HOME)/run/qemu
	mv $(NAND_WR_OUT) $@

# TOOD: make a real hpps/rootfs folder? (for autocompelte and consistency)
.PHONY: $(PROF_BLD)/hpps/rootfs $(PROF_BLD)/hpps/rootfs/clean
$(PROF_BLD)/hpps/rootfs: $(PROF_BLD)/hpps/prof.rootfs.nand.bin
$(PROF_BLD)/hpps/rootfs/clean:
	find $(PROF_BLD)/hpps -maxdepth 1 \
		$(if $(filter nand,$(CLEAN)),-false,-path '$(CLEAN_nand)') -prune \
			-exec echo '$@: path locked (set CLEAN=nand to clean):' {} \; -o \
		-o -not \( -path $(PROF_BLD)/hpps \) -name '*rootfs*' -exec rm -rf {} \;

# Extract ramoops buffer and parse binary ftrace data image into text

.PHONY: $(PROF_BLD)/hpps/ramoops $(PROF_BLD)/hpps/ramoops/clean
$(PROF_BLD)/hpps/ramoops: $(PROF_BLD)/hpps/ramoops.txt
$(PROF_BLD)/hpps/ramoops/clean:
	rm -f $(PROF_BLD)/hpps/ramoops/ramoops.{bin,txt}

FTRACE_EX_PROF := tool-ftrace-extractor
FRACE_EX_HOME := $(PROF_PROF)/$(FRACE_EX_PROF)

$(PROF_BLD)/hpps/ramoops/ramoops.bin:
	source $(CONF)/$(FTRACE_EX_PROF)/conf-ramoops.sh && \
	qmp.py localhost $$DUT_QMP_PORT pmemsave \
	    val=$$RAMOOPS_ADDR size=$$RAMOOPS_SIZE \
		filename="\"$(abspath $@)\"" cpu-index=$$RAMOOPS_CPU

$(PROF_BLD)/hpps/ramoops/ramoops.txt: $(PROF_BLD)/hpps/ramoops/ramoops.bin
	$(COPY) $< $(FTRACE_EX_HOME)/input.ramoops.bin
	CONF=$(CONF) source $(CONF)/$(FTRACE_EX_PROF)/conf.sh && \
	qmp-mem-wait -p $$(ps -o ppid= $$$$) \
		localhost $$QMP_PORT $$DONE_CPU $$DONE_ADDR $$DONE_PATTERN \
		$(CONF)/$(FTRACE_EX_PROF)/dump-ramoops.sh $$QMP_PORT "$@" \&\& \
		qmp.py localhost $$QMP_PORT quit & \
	$(MAKE) PROF=$(FTRACE_EX_PROF) PRIV=1 PROF_HOME=$(FRACE_EX_HOME) \
		$(FRACE_EX_PROF)/run/qemu


# Common function to determine whether profile's artifact are shared
# A profile can share another profile's artifacts by adding the dependee
# profile name to SHARE variable and then including the dependee profile.
#
# Note that the top-level makefile that consumes the artifact needs to
# provide one level of indirection: an extra real target with a recipe
# that copies its prerequisites (defined by the profile). Otherwise,
# the profile would be overriding a target, which is not allowed.
#
# Note: if need be can easily implement sharing of a subset of artifacts
# by listing patterns in a SHARE_profname variable and filtering here.
# prototype: share(this_prof_aka_dependee,SHARE list)
share=$(strip $(if $(filter $(PROF),$(1)),,$(if $(filter $(1),$(2)),true,)))

# Initialize list of artifacts built by the profile
PROF_ARTS :=

# Functions (with sideeffects!) for getting the name of the current profile
# i.e. the one that is being included, as opposed to the one being built (PROF)
# Each profile (that has includes) has to call push-prof before its includes
# and call pop-prof (that returns its own name) after its includes.  Some
# complexity in return for being able to rename a profile without modifying it.
curr-prof=$(notdir $(patsubst %/,%,$(dir $(lastword $(MAKEFILE_LIST)))))
push-prof=$(eval PSTACK=$(call curr-prof) $(PSTACK))
pop-prof=$(firstword $(PSTACK))$(eval PSTACK:=$(wordlist 2,$(words $(PSTACK)),$(PSTACK)))

# For sharing artifacts across profiles
# share-rule(this-prof,artifact)
define share-rule
$(2):
	@echo "ERROR: Dependent profile not built: build $(1) before $(PROF)" 2>&1
	exit 1
endef
share-path=$(PROFDIR)/$(1)/$(BLDDIR)/$(2)
share-art=$(call share-path,$(1),$(2))\
		  $(eval $(call share-rule,$(1),$(call share-path,$(1),$(2))))

# Load selected profile
# 
# Note: we cannot declare the rules for privatizable module before including
# the profiles, because need the artifact list to declare the module rules.

# To allow profile makefiles to refer to S_* (source tree path) variables
# Note: we can't just include later, because we need PROF_ARTS to define S_*.
.SECONDEXPANSION:
include $(CONF)/$(PROF)/Makefile

# Artifacts added by the profile implicitly by mentioning them in a mem map:
# add to the artifacts list and to the dependency tree.
# Note: Must do this for clean targets too, because the affects privatization
include $(patsubst %.mem.map,%.mem.dep,$(filter %.mem.map,$(PROF_ARTS)))

# Extract the dependencies from a memory map file
$(PROF_BLD)/%.mem.dep: $(PROF_BLD)/%.exp.mem.map
	memmap-rules -o $@ --artifacts PROF_ARTS $<
# For sfs mem map we know the image, so also add deps on the image
$(PROF_BLD)/%.sfs.mem.dep: $(PROF_BLD)/%.sfs.exp.mem.map
	memmap-rules -o $@ -m '-' --image $(@:.dep=.bin) --artifacts PROF_ARTS $<

# Targets that generate the artifacts for each module
#
# For each module, we provide the following targets:
#   1. non-phony targets for each artifact produced by the nested build within
#      the module.  These non-phony targets participate in the top level
#      dependency tree whereas phony targets do not -- see below for details.
#	   Artifacts are copied into profile build directory to make it make it
#	   easier to write profile files (not have to worry whether the profile was
#	   built in privatized mode (where source directories where copied).
#   2. a phony target, named same as the module, that forces the nested build
#   3. a phony clean target named module-clean
#
# Invariant: artifacts have a unique recipe. That unique recipe may part of two
# different dependency trees: (A) the dependency tree for the user interface
# target (aka. an alias), or (B) the dependency tree of another artifact (e.g.
# a memory image). Also we have the requirement that rule for nested artifacts
# trigger the nested dependency build. This won't happen if the rule here
# depends on the artifact, so, e.g. 'hpps-linux: arch/arm64/boot/Image' would
# not be good because when you change 'kernel.c' and 'make hpps-linux' nothing
# will be rebuilt. In other words, the dep tree would be truncated at that
# artifact -- if the artifact already exists, no recipe will be invoked, even
# if its dependencies in the (invisible) nested tree are stale.
#
# This invariant plus the requirements determines the pattern: the recipe for
# invoking the nested dependency building for a nested artifact is associated
# with a phony target. Then, both the user-facing alias (case A) and the
# artifact (case B) both depend on that phony target. Most often there's no
# alias (case A) because the phony target is short enough to be user-facing.
#
# Another non-way to satisfy invariant+requirement would be to use only the
# phony targets for the artifacts here (i.e. eliminate Case B rule), but this
# hinders rule legibility because dependencies can no longer be explicit
# artifacts (they are phony targets) and the recipies can no longer refer to
# dependencies (e.g. via $<).
#
# Note: recipies that invoke nested make in order to build a non-phony artifact
# need to be sequenced in order to prevent nested builds from running in parallel.
# For example for Linux: .config -> Image -> modules.order ->
# modules_install. This is done by chaining these artifacts as dependencies.

## Logic to autodetect which modules to privatize (copy sources into a separate
# directory, and clean them), based on which artifacts the profile builds.
#
# Artifacts produced by a module's nested build must trigger privatization,
# because in case a privated tool profile (e.g. nand-writer) is built as part
# of the top-level build, that tool profile's build will invoke the same
# nested builds as the top-level build, which will conflict. To detect the
# modules that build such "nested" artifacts in the profile, we simply place
# these "nested" nested artifacts (and only them) into a dedicated subdirectory,
# and check for that subdirectory's name in the artifact's target by the filter
# function below. When selecting artifacts to build (explicitly by adding to
# PROF_ARTS or implicitly by referring in the config files), the profile should
# only reference artifacts that are in the main build directory $(PROF_BLD) or
# the dedicated subdirectory $(B_module), but and not in the source tree
# (which can be privatized) -- so detection does not cover the latter.
#
# If nested artifacts from a module are being built by the profile, set S_* to
# privatized copy before referencing the $(S_*) in any of the rules.  We could
# set the S_* vars in a loop, but then the artifact lists for each module would
# need to be in a list at the top (away from the module's rules). So, in the
# following, B_* definition must come before the call to src func for S_ def.

# Returns shared or privatized path depending on PRIV and profile's artifacts
if-priv=$(if $(and $(PRIV),$(filter $(B_$(1):=/%),$(PROF_ARTS))),$(2),$(3))
#src=$(if $(and $(PRIV),$(filter $(B_$(1):=/%),$(PROF_ARTS))),\
#	  $(PROF_HOME)/$(SRCDIR)/$(L_$(1)),$(L_$(1)))
src=$(call if-priv,$(1),$(PROF_HOME)/$(SRCDIR)/$(L_$(1)),$(L_$(1)))
src-ok=$(call if-priv,$(1),$(PROF_OK)/$(SRCDIR)/$(L_$(1))/ok,$(PROF_OK)/$(L_$(1)/ok))

# Returns the phony target that triggers the module's nested build, if DEEP
depth-prereq = $(if $(filter $(DEEP),$(filter-out $(SHALLOW),$(1))),$(1))
mod-prereq = $(if $(call depth-prereq,$(1)),$(B_$(1)))

# For each module, the artifacts produced by the nested build are copied into a
# dedicated subdirectory. This is important for the autodetection of modules to
# privatize (see above). Not all artifacts (loosely) associated with a module
# are produced by the nested build -- some are produced from sources (not built
# artifacts!) by recipes defined here -- only the former and not the latter
# need to be in the dedicated subdirectory. If an artifact produced by a recipe
# defined here derives from a nested artifact, the former artifact also needs
# to go into the dedicated subdirectory (because it would inoke the nested
# build, even if transitively). The dedicated subdirectory is in B_module
# variable.
#
# Also, the recipe that copies a nested artifact into the dedicated subdir
# is in a dedicated target (as opposed to a command in the target that
# invokes the nested build). We should not invoke the nested build if the
# artifact is already up to date and just needs to be copied (e.g. maybe the
# user built the module manually).
#
# To summarize, for example:
#	  $(S_trch-bm)/bld/trch.elf: artifact within the nested build
#     $(B_trch-bm)/trch.elf: artifact from nested build
#     $(PROF_BLD)/trch/syscfg.ini: artifact not from nested build

# The baremetal srctree makes up two modules, but they are not
# standalone: the source must be privatized once for both, so
# we mark the two modules as "unprivatizable", and create one
# module marked "privatize-only" to privatize the source.
PARENTS += bm
L_bm := hpsc-baremetal

MODULES += trch-bm
P_trch-bm := bm
L_trch-bm := $(L_bm)/trch
B_trch-bm := $(PROF_BLD)/trch/bm
S_trch-bm := $(call src,trch-bm)
KEEP_DIRS += $(PROF_BLD)/trch

TRCH_BM_ARGS=CROSS_COMPILE=$(CROSS_M4)
SYSCFG_SCHEMA:=syscfg-schema.json

$(PROF_BLD)/trch/bm.config.mk: | $(PROF_BLD)/trch/
$(S_trch-bm)/Makefile.config: $(PROF_BLD)/trch/bm.config.mk $(call src-ok,trch-bm)
	cp $< $@

$(B_trch-bm): $(S_trch-bm)/Makefile.config
	$(MAKE) -C $(S_trch-bm) $(TRCH_BM_ARGS)
$(B_trch-bm)/clean:
	[ ! -d $(S_trch-bm) ] || ( \
		$(MAKE) -C $(S_trch-bm) $(TRCH_BM_ARGS) clean && \
		rm -f $(S_trch-bm)/Makefile.config \
	)

# An empty recipe rather than just a dependency, because if we have an
# unrelated implicit rule that happens to match this target (e.g. %.elf),
# then the recipe of that unrelated rule will be run.
$(S_trch-bm)/bld/trch.elf \
$(S_trch-bm)/bld/trch.dbg.elf \
: $(call mod-prereq,trch-bm) ;

$(S_trch-bm)/$(SYSCFG_SCHEMA): $(call src-ok,trch-bm) ;

# Note: must depend on nested phony target directly, not just transitively, to
# rebuild this artifact when prereq file already exists from an old nested build.
$(B_trch-bm)/trch.elf: $(S_trch-bm)/bld/trch.elf $(call mod-prereq,trch-bm) | $(B_trch-bm)/
	$(COPY) $< $@
$(B_trch-bm)/trch.dbg.elf: $(S_trch-bm)/bld/trch.dbg.elf | $(B_trch-bm)/
	$(COPY) $< $@

$(PROF_BLD)/trch/syscfg.ini: | $(PROF_BLD)/trch/
$(PROF_BLD)/trch/syscfg.bin: $(PROF_BLD)/trch/syscfg.ini $(S_trch-bm)/$(SYSCFG_SCHEMA)
	cfgc -s $(S_trch-bm)/$(SYSCFG_SCHEMA) $< $@

MODULES += rtps-r52-bm
P_trch-bm := bm
L_rtps-r52-bm := $(L_bm)/rtps
B_rtps-r52-bm := $(PROF_BLD)/rtps/r52/bm
S_rtps-r52-bm := $(call src,rtps-r52-bm)
KEEP_DIRS += $(PROF_BLD)/rtps

RTPS_R52_BM_ARGS=CROSS_COMPILE=$(CROSS_R52)

$(PROF_BLD)/rtps/r52/bm.config.mk : | $(PROF_BLD)/rtps/r52/
$(S_rtps-r52-bm)/Makefile.config: $(PROF_BLD)/rtps/r52/bm.config.mk $(call src-ok,rtps-r52-bm)
	cp $< $@

$(B_rtps-r52-bm): $(S_rtps-r52-bm)/Makefile.config
	$(MAKE) -C $(S_rtps-r52-bm) $(RTPS_R52_BM_ARGS)
$(B_rtps-r52-bm)/clean: 
	[ ! -d $(S_rtps-r52-bm) ] || ( \
		$(MAKE) -C $(S_rtps-r52-bm) $(RTPS_R52_BM_ARGS) clean && \
		rm -f $(S_rtps-r52-bm)/Makefile.config \
	)

$(S_rtps-r52-bm)/bld/rtps.uimg \
$(S_rtps-r52-bm)/bld/rtps.dbg.elf \
: $(call mod-prereq,rtps-r52-bm) ;

$(B_rtps-r52-bm)/rtps.uimg: $(S_rtps-r52-bm)/bld/rtps.uimg \
							$(call mod-prereq,rtps-r52-bm) | $(B_rtps-r52-bm)/
	$(COPY) $< $@
$(B_rtps-r52-bm)/rtps.dbg.elf: $(S_rtps-r52-bm)/bld/rtps.dbg.elf \
							   $(call mod-prereq,rtps-r52-bm) | $(B_rtps-r52-bm)/
	$(COPY) $< $@

MODULES += rtps-r52-uboot
L_rtps-r52-uboot := rtps/r52/u-boot
B_rtps-r52-uboot := $(PROF_BLD)/rtps/r52/u-boot
S_rtps-r52-uboot := $(call src,rtps-r52-uboot)

RTPS_R52_UBOOT_ARGS=CROSS_COMPILE=$(CROSS_R52)

$(S_rtps-r52-uboot)/configs/hpsc_rtps_r52_defconfig: $(call src-ok,rtps-r52-uboot) ;
$(S_rtps-r52-uboot)/.config: $(S_rtps-r52-uboot)/configs/hpsc_rtps_r52_defconfig
	$(MAKE) -C $(S_rtps-r52-uboot) $(RTPS_R52_UBOOT_ARGS) hpsc_rtps_r52_defconfig

$(B_rtps-r52-uboot): $(S_rtps-r52-uboot)/.config
	$(MAKE) -C $(S_rtps-r52-uboot) $(RTPS_R52_UBOOT_ARGS) u-boot u-boot.bin
$(B_rtps-r52-uboot)/clean:
	[ ! -d $(S_rtps-r52-uboot) ] || ( \
		$(MAKE) -C $(S_rtps-r52-uboot) $(RTPS_R52_UBOOT_ARGS) clean && \
		rm -f $(S_rtps-r52-uboot)/.config \
	)

$(S_rtps-r52-uboot)/u-boot.bin \
$(S_rtps-r52-uboot)/u-boot \
: $(call mod-prereq,rtps-r52-uboot) ;

$(B_rtps-r52-uboot)/u-boot.bin: $(S_rtps-r52-uboot)/u-boot.bin \
							    $(call mod-prereq,rtps-r52-uboot) | $(B_rtps-r52-uboot)/
	$(COPY) $< $@
$(B_rtps-r52-uboot)/u-boot.dbg.elf: $(S_rtps-r52-uboot)/u-boot \
							        $(call mod-prereq,rtps-r52-uboot) | $(B_rtps-r52-uboot)/
	$(COPY) $< $@

MODULES += rtps-a53-uboot
L_rtps-a53-uboot := rtps/a53/u-boot
B_rtps-a53-uboot := $(PROF_BLD)/rtps/a53/u-boot
S_rtps-a53-uboot := $(call src,rtps-a53-uboot)

RTPS_A53_UBOOT_ARGS=CROSS_COMPILE=$(CROSS_A53)

$(S_rtps-a53-uboot)/configs/hpsc_rtps_a53_defconfig: $(call src-ok,rtps-a53-uboot)
$(S_rtps-a53-uboot)/.config: $(S_rtps-a53-uboot)/configs/hpsc_rtps_a53_defconfig
	$(MAKE) -C $(S_rtps-a53-uboot) $(RTPS_A53_UBOOT_ARGS) hpsc_rtps_a53_defconfig

$(B_rtps-a53-uboot): $(S_rtps-a53-uboot)/.config
	$(MAKE) -C $(S_rtps-a53-uboot) $(RTPS_A53_UBOOT_ARGS) u-boot u-boot.bin
$(B_rtps-a53-uboot)/clean:
	[ ! -d $(S_rtps-a53-uboot) ] || ( \
		$(MAKE) -C $(S_rtps-a53-uboot) $(RTPS_A53_UBOOT_ARGS) clean && \
		rm -f $(S_rtps-a53-uboot)/.config \
	)
	
$(S_rtps-a53-uboot)/u-boot.bin \
$(S_rtps-a53-uboot)/u-boot \
: $(call mod-prereq,rtps-a53-uboot) ;

# Note: must depend on the nested phony target directly (see comment in first module)
$(B_rtps-a53-uboot)/u-boot.bin: $(S_rtps-a53-uboot)/u-boot.bin \
							    $(call mod-prereq,rtps-a53-uboot) | $(B_rtps-a53-uboot)/
	$(COPY) $< $@
$(B_rtps-a53-uboot)/u-boot.dbg.elf: $(S_rtps-a53-uboot)/u-boot \
							    $(call mod-prereq,rtps-a53-uboot) | $(B_rtps-a53-uboot)/
	$(COPY) $< $@

MODULES += rtps-a53-atf
L_rtps-a53-atf := rtps/a53/arm-trusted-firmware
B_rtps-a53-atf := $(PROF_BLD)/rtps/a53/atf
S_rtps-a53-atf := $(call src,rtps-a53-atf)

RTPS_A53_ATF_PLAT := hpsc_rtps_a53
RTPS_A53_ATF_BLD := build/$(RTPS_A53_ATF_PLAT)/debug
RTPS_A53_ATF_ARGS = PLAT=$(RTPS_A53_ATF_PLAT) DEBUG=1 CROSS_COMPILE=$(CROSS_A53)

$(B_rtps-a53-atf): $(call src-ok,rtps-a53-atf)
	$(MAKE) -C $(S_rtps-a53-atf) $(RTPS_A53_ATF_ARGS) bl31
$(B_rtps-a53-atf)/clean:
	[ ! -d $(S_rtps-a53-atf) ] || $(MAKE) -C $(S_rtps-a53-atf) $(RTPS_A53_ATF_ARGS) clean

$(S_rtps-a53-atf)/$(RTPS_A53_ATF_BLD)/bl31.bin \
$(S_rtps-a53-atf)/$(RTPS_A53_ATF_BLD)/bl31/bl31.elf \
: $(call mod-prereq,rtps-a53-atf) ;

$(B_rtps-a53-atf)/atf.bin: $(S_rtps-a53-atf)/$(RTPS_A53_ATF_BLD)/bl31.bin \
						 $(call mod-prereq,rtps-a53-atf)| $(B_rtps-a53-atf)/
	$(COPY) $< $@
$(B_rtps-a53-atf)/atf.dbg.elf: $(S_rtps-a53-atf)/$(RTPS_A53_ATF_BLD)/bl31/bl31.elf \
						       $(call mod-prereq,rtps-a53-atf)| $(B_rtps-a53-atf)/
	$(COPY) $< $@

MODULES += hpps-atf
L_hpps-atf := hpps/arm-trusted-firmware
B_hpps-atf := $(PROF_BLD)/hpps/atf
S_hpps-atf := $(call src,hpps-atf)

HPPS_ATF_PLAT := hpsc
HPPS_ATF_BLD := build/$(HPPS_ATF_PLAT)/debug
HPPS_ATF_ARGS = PLAT=$(HPPS_ATF_PLAT) DEBUG=1 CROSS_COMPILE=$(CROSS_A53)

$(B_hpps-atf): $(call src-ok,hpps-atf)
	$(MAKE) -C $(S_hpps-atf) $(HPPS_ATF_ARGS) bl31
$(B_hpps-atf)/clean:
	[ ! -d $(S_hpps-atf) ] || $(MAKE) -C $(S_hpps-atf) $(HPPS_ATF_ARGS) clean

$(S_hpps-atf)/$(HPPS_ATF_BLD)/bl31.bin \
$(S_hpps-atf)/$(HPPS_ATF_BLD)/bl31/bl31.elf \
: $(call mod-prereq,hpps-atf) ;

$(B_hpps-atf)/atf.bin: $(S_hpps-atf)/$(HPPS_ATF_BLD)/bl31.bin \
					   $(call mod-prereq,hpps-atf) | $(B_hpps-atf)/
	$(COPY) $< $@
$(B_hpps-atf)/atf.dbg.elf: $(S_hpps-atf)/$(HPPS_ATF_BLD)/bl31/bl31.elf \
					   	   $(call mod-prereq,hpps-atf) | $(B_hpps-atf)/
	$(COPY) $< $@

MODULES += hpps-uboot
L_hpps-uboot := hpps/u-boot
B_hpps-uboot := $(PROF_BLD)/hpps/u-boot
S_hpps-uboot := $(call src,hpps-uboot)
KEEP_DIRS += $(PROF_BLD)/hpps

HPPS_UBOOT_ARGS=CROSS_COMPILE=$(CROSS_A53)

$(S_hpps-uboot)/configs/hpsc_hpps_defconfig \
$(S_hpps-uboot)/arch/arm/dts/hpsc-hpps.dts \
: $(call src-ok,hpps-uboot) ;
$(S_hpps-uboot)/.config: $(S_hpps-uboot)/configs/hpsc_hpps_defconfig
	$(MAKE) -C $(S_hpps-uboot) $(HPPS_UBOOT_ARGS) hpsc_hpps_defconfig

$(B_hpps-uboot): $(S_hpps-uboot)/.config
	$(MAKE) -C $(S_hpps-uboot) $(HPPS_UBOOT_ARGS) u-boot u-boot-nodtb.bin u-boot.dtb
$(B_hpps-uboot)/clean:
	[ ! -d $(S_hpps-uboot) ] || ( \
		$(MAKE) -C $(S_hpps-uboot) $(HPPS_UBOOT_ARGS) clean && \
		rm -f $(S_hpps-uboot)/.config \
	)

$(S_hpps-uboot)/u-boot-nodtb.bin \
$(S_hpps-uboot)/u-boot.dtb \
$(S_hpps-uboot)/u-boot \
: $(call mod-prereq,hpps-uboot) ;

$(B_hpps-uboot)/u-boot-nodtb.bin: $(S_hpps-uboot)/u-boot-nodtb.bin \
								  $(call mod-prereq,hpps-uboot) | $(B_hpps-uboot)/
	$(COPY) $< $@
$(B_hpps-uboot)/u-boot.dbg.elf: $(S_hpps-uboot)/u-boot \
								$(call mod-prereq,hpps-uboot) | $(B_hpps-uboot)/
	$(COPY) $< $@

$(PROF_BLD)/hpps/u-boot.env: | $(PROF_BLD)/hpps/
$(PROF_BLD)/hpps/u-boot.env.bin: $(PROF_BLD)/hpps/u-boot.env $(PROF_BLD)/hpps/conf.sh
	source $(PROF_BLD)/hpps/conf.sh && \
	mkenvimage -s $$HPPS_UBOOT_ENV_SIZE -o $@ $<
$(PROF_BLD)/hpps/u-boot.dts: | $(PROF_BLD)/hpps/
$(PROF_BLD)/hpps/u-boot.dtb: $(PROF_BLD)/hpps/u-boot.dts | $(call src-ok,hpps-uboot) $(PROF_BLD)/hpps/
	$(call dtc-cmd,-I$(S_hpps-uboot)/arch/arm/dts \
		-I$(S_hpps-uboot)/arch/arm/dts/include -I$(S_hpps-uboot)/include)

MODULES += hpps-linux
L_hpps-linux := hpps/linux
B_hpps-linux := $(PROF_BLD)/hpps/linux
S_hpps-linux := $(call src,hpps-linux)
KEEP_DIRS += $(PROF_BLD)/hpps

HPPS_LINUX_ARCH := arch/arm64
HPPS_LINUX_BOOT := $(HPPS_LINUX_ARCH)/boot
HPPS_LINUX_CFGS := $(HPPS_LINUX_ARCH)/configs
HPPS_LINUX_ARGS = ARCH=arm64 CROSS_COMPILE=$(CROSS_A53)

$(S_hpps-linux)/$(HPPS_LINUX_CFGS)/hpsc_defconfig \
$(S_hpps-linux)/$(HPPS_LINUX_BOOT)/dts/hpsc/hpsc.dts \
: $(call src-ok,hpps-linux) ;
$(S_hpps-linux)/.config: $(S_hpps-linux)/$(HPPS_LINUX_CFGS)/hpsc_defconfig
	$(MAKE) -C $(S_hpps-linux) $(HPPS_LINUX_ARGS) $(<F)

$(B_hpps-linux): $(S_hpps-linux)/.config
	$(MAKE) -C $(S_hpps-linux) $(HPPS_LINUX_ARGS) Image Image.gz modules
$(B_hpps-linux)/clean:
	[ ! -d $(S_hpps-linux) ] || \
		$(MAKE) -C $(S_hpps-linux) $(HPPS_LINUX_ARGS) mrproper

$(S_hpps-linux)/$(HPPS_LINUX_BOOT)/Image \
$(S_hpps-linux)/$(HPPS_LINUX_BOOT)/Image.gz \
$(S_hpps-linux)/vmlinux \
: $(call mod-prereq,hpps-linux) ;

$(B_hpps-linux)/Image: $(S_hpps-linux)/$(HPPS_LINUX_BOOT)/Image
	$(COPY) $< $@
$(B_hpps-linux)/Image.gz: $(S_hpps-linux)/$(HPPS_LINUX_BOOT)/Image.gz
	$(COPY) $< $@
$(B_hpps-linux)/vmlinux: $(S_hpps-linux)/$(HPPS_LINUX_BOOT)/vmlinux
	$(COPY) $< $@

# Note: must depend on the nested phony target directly (see comment in first module)
$(B_hpps-linux)/uImage: $(S_hpps-linux)/$(HPPS_LINUX_BOOT)/Image.gz \
						$(PROF_BLD)/hpps/conf.sh \
						$(call mod-prereq,hpps-linux) | $(B_hpps-linux)/
	source $(PROF_BLD)/hpps/conf.sh && \
	mkimage -T kernel -C gzip -A arm64 -d "$<" -a $$HPPS_KERN_LOAD_ADDR "$@"
$(B_hpps-linux)/linux.dbg.elf: $(S_hpps-linux)/vmlinux \
							   $(call mod-prereq,hpps-linux) | $(B_hpps-linux)/
	$(COPY) $< $@
$(B_hpps-linux)/modules.fr.dir: $(or $(call mod-prereq,hpps-linux),$(S_hpps-linux)/modules.order) \
								| $(B_hpps-linux)/
	fakeroot -s $@.fr \
		$(MAKE) -C $(S_hpps-linux) $(HPPS_LINUX_ARGS) \
			INSTALL_MOD_PATH="$(abspath $@)" modules_install
	touch $@
$(PROF_BLD)/hpps/linux.dts: | $(PROF_BLD)/hpps/
$(PROF_BLD)/hpps/linux.dtb: $(PROF_BLD)/hpps/linux.dts
	$(call dtc-cmd,-I$(S_hpps-linux)/include -I$(S_hpps-linux)/$(HPPS_LINUX_BOOT)/dts/hpsc)

MODULES += hpps-busybox
L_hpps-busybox := hpps/busybox
B_hpps-busybox := $(PROF_BLD)/hpps/busybox
S_hpps-busybox := $(call src,hpps-busybox)
KEEP_DIRS += $(PROF_BLD)/hpps

HPPS_BUSYBOX_ARGS = CROSS_COMPILE=$(CROSS_A53_LINUX)

$(PROF_BLD)/hpps/busybox.miniconf: | $(B_hpps-busybox)/

$(S_hpps-busybox)/.config: $(PROF_BLD)/hpps/busybox.miniconf $(call src-ok,hpps-busybox)
	$(MAKE) -C $(S_hpps-busybox) $(HPPS_BUSYBOX_ARGS) \
		allnoconfig KCONFIG_ALLCONFIG="$(abspath $<)"

$(B_hpps-busybox): $(S_hpps-busybox)/.config
	$(MAKE) -C $(S_hpps-busybox) $(HPPS_BUSYBOX_ARGS)
$(B_hpps-busybox)/clean:
	[ ! -d $(S_hpps-busybox) ] || ( \
		$(MAKE) -C $(S_hpps-busybox) $(HPPS_BUSYBOX_ARGS) clean && \
		rm -f $(S_hpps-busybox)/.config \
	)

$(S_hpps-busybox)/busybox: $(call mod-prereq,hpps-busybox) ;

$(B_hpps-busybox)/busybox.fr.dir: $(or $(call mod-prereq,hpps-busybox),$(S_hpps-busybox)/busybox) \
								  | $(B_hpps-busybox)/
	fakeroot -s $@.fr \
		$(MAKE) -j1 -C $(S_hpps-busybox) $(HPPS_BUSYBOX_ARGS) \
			CONFIG_PREFIX="$(abspath $@)" install
	touch $@

MODULES += hpps-linux-tests
L_hpps-linux-tests := $(HPSC_UTILS)/test/linux
B_hpps-linux-tests := $(PROF_BLD)/hpps/test/linux
S_hpps-linux-tests := $(call src,hpps-linux-tests)
KEEP_DIRS += $(PROF_BLD)/hpps/test/linux

HPPS_LINUX_TESTS_ARGS = CROSS_COMPILE=$(CROSS_A53_LINUX) CC=gcc

$(B_hpps-linux-tests): $(call src-ok,hpps-linux-tests)
	$(MAKE) -C $(S_hpps-linux-tests) $(HPPS_LINUX_TESTS_ARGS)
$(B_hpps-linux-tests)/clean:
	[ ! -d $(S_hpps-linux-test) ] || \
		$(MAKE) -C $(S_hpps-linux-tests) $(HPPS_LINUX_TESTS_ARGS) clean

# Pick some artifact that indicates completed build (relevant only for shallow build)
$(S_hpps-linux-tests)/mboxtester: $(call mod-prereq,hpps-linux-tests) ;

$(B_hpps-linux-tests)/tests.fr.dir: $(if $(DEEP),$(B_hpps-linux-tests),\
												 $(S_hpps-linux-tests)/mboxtester) \
								    | $(B_hpps-linux-tests)/
	fakeroot -s $@.fr \
		$(MAKE) -C $(S_hpps-linux-tests) $(HPPS_LINUX_TESTS_ARGS) \
			DEST="$(abspath $@)/usr/bin/tests" install
	touch $@

MODULES += hpps-yocto
UNPRIV += hpps-yocto
L_hpps-yocto := hpps/yocto
B_hpps-yocto := $(PROF_BLD)/hpps/yocto
S_hpps-yocto := $(call src,hpps-yocto)
KEEP_DIRS += $(PROF_BLD)/hpps

YOCTO_BB := $(B_hpps-yocto)/bb
YOCTO_CONF := $(YOCTO_BB)/conf
YOCTO_DL_DIR ?= $(L_hpps-yocto)/poky_dl
YOCTO_ENV := poky/oe-init-build-env
YOCTO_CONFS:=local.conf bblayers.conf
YOCTO_CONF_PATHS=$(patsubst %,$(YOCTO_CONF)/%,$(YOCTO_CONFS))
YOCTO_TARGET:=core-image-hpsc
YOCTO_IMG := tmp-glibc/deploy/images/hpsc-chiplet/core-image-hpsc-hpsc-chiplet.tar.gz

$(PROF_BLD)/hpps/yocto-local.conf \
$(PROF_BLD)/hpps/yocto-bblayers.conf \
: | $(PROF_BLD)/hpps/
# In both cases, must have absolute paths
$(YOCTO_CONF)/local.conf: $(PROF_BLD)/hpps/yocto-local.conf | $(YOCTO_CONF)/
	mkdir -p $(YOCTO_DL_DIR)
	sed 's@___YOCTO_DL_DIR___@$(abspath $(YOCTO_DL_DIR))@g' $< > $@
$(YOCTO_CONF)/bblayers.conf: $(PROF_BLD)/hpps/yocto-bblayers.conf | $(YOCTO_CONF)/
	sed 's@___YOCTO_SRC_DIR___@$(abspath $(L_hpps-yocto))@g' $< > $@

$(B_hpps-yocto): $(YOCTO_CONF_PATHS)
	source $(S_hpps-yocto)/$(YOCTO_ENV) $(YOCTO_BB) && bitbake $(YOCTO_TARGET)
$(B_hpps-yocto)/fetch: $(YOCTO_CONF_PATHS)
	source $(S_hpps-yocto)/$(YOCTO_ENV) $(YOCTO_BB) && \
		bitbake $(YOCTO_TARGET) --runall="fetch"
.PHONY: $(B_hpps-yocto)/fetch
$(B_hpps-yocto)/build/%: $(YOCTO_CONF_PATHS) PHONY
	source $(S_hpps-yocto)/$(YOCTO_ENV) $(YOCTO_BB) && bitbake $*
$(B_hpps-yocto)/clean/%: $(YOCTO_CONF_PATHS) PHONY
	source $(S_hpps-yocto)/$(YOCTO_ENV) $(YOCTO_BB) && bitbake -c clean $*
$(B_hpps-yocto)/clean:
	@$(if $(filter $(CLEAN),yocto),true,false) || \
		( echo "$@: group 'yocto' is locked (to clean it set CLEAN=yocto)." 2>&1 && exit 1 )
	[[ ! -d $(S_hpps-yocto) $(foreach c,$(YOCTO_CONF_PATHS),|| ! -f "$(c)") ]] || ( \
		source $(S_hpps-yocto)/$(YOCTO_ENV) $(YOCTO_BB) && \
			bitbake -c clean $(YOCTO_TARGET) && \
		rm -rf "$(YOCTO_CONF_PATHS)" \
	)

$(YOCTO_BB)/$(YOCTO_IMG): $(call mod-prereq,hpps-yocto) ;

# Note: must depend on the nested phony target directly (see comment in first module)
$(B_hpps-yocto)/yocto.rootfs.tar.gz: $(YOCTO_BB)/$(YOCTO_IMG) \
									 $(call mod-prereq,hpps-yocto) | $(B_hpps-yocto)/
	$(COPY) $< $@
# The profile must add the desired source as a prereq (yocto.rootfs.tar.gz or other)
# Note: placed outside of the module, so that yocto module doesn't get pulled in
# profiles that use a shared artifact that they don't themselves build
$(PROF_BLD)/hpps/prof.yocto.rootfs.tar.gz: | $(PROF_BLD)/hpps/
	@[ ! -z "$^" ] || ( echo "ERROR: no source prereq for: $@" 2>&1 && exit 1 )
	$(COPY) $< $@

## Common rules for all modules

# Support for optionally privatizing sources by making a copy.
# PRIV can be set to 1 at time of invoking make.
# To support modules that share a source trees (actual shared common files),
# add conditionals: copy only modules without a parent, clean only modules.
define src-rule
$(PROF_OK)/$(L_$(1))/ok: | $(L_$(1)) $(PROF_OK)/$(L_$(1))/
	touch $$@
$(PROF_OK)/$(SRCDIR)/$(L_$(1))/ok: \
			$(if $(P_$(1)),$(PROF_OK)/$(SRCDIR)/$(L_$(P_$(1)))/ok) | $(L_$(1)) \
	$(PROF_OK)/$(SRCDIR)/$(L_$(1))/ $(PROF_SRC)/$(L_$(1))/
	$(if $(P_$(1)),,$(RSYNC) -aq --exclude=.git/ $(L_$(1))/ $(PROF_SRC)/$(L_$(1)))
	$(if $(filter $(1),$(MODULES)),$$(MAKE) PROF=$(PROF) PRIV=$(PRIV) CLEAN=% $(B_$(1))/clean)
	touch $$@
.PHONY: $(PROF_SRC)/$(L_$(1))
$(PROF_SRC)/$(L_$(1)): $(PROF_OK)/$(SRCDIR)/$(L_$(1))/ok
$(PROF_SRC)/$(L_$(1))/clean:
	rm -rf "$(PROF_SRC)/$(L_$(1))"
$(PROF_SRC): $(PROF_SRC)/$(L_$(1))
endef
$(PROF_SRC)/clean:
	rm -rf "$(PROF_SRC)" "$(PROF_OK)"
.PHONY: $(PROF_SRC) $(PROF_SRC)/clean

$(foreach m,$(MODULES),$(eval .PHONY: $(B_$(m)) $(B_$(m))/clean)\
					   $(eval KEEP_DIRS += $(B_$(m))))

$(foreach m,$(filter-out $(UNPRIV),$(MODULES) $(PARENTS)),$(eval $(call src-rule,$(m))))

# Subset of modules built by the profile
PROF_MODS := $(foreach m,$(MODULES),$(if $(filter $(B_$(m):=/%),$(PROF_ARTS)),$(m)))

.PHONY: $(PROF_HOME) $(PROF_HOME)/clean $(PROF_BLD)
$(PROF_HOME): $(PROF_BLD)
$(PROF_BLD): $(PROF_ARTS)

# Deep clean that invokes nested builds (unless overriden with DEEP=0), to
# clean artifacts in bld/ (without invoking nested build at all -- not cleaning
# it) use the $(PROF_BLD)/bld/clean target instead
$(PROF_HOME)/clean: $(if $(DEEP),$(foreach m,$(PROF_MODS),$(B_$(m))/clean)) \
	$(PROF_BLD)/clean $(PROF_SRC)/clean $(PROF_RUN)/clean $(PROF_PROF)/clean

## Some artifacts are very time-consuming to build, so require
# the user to set a variable to allow cleaning them: CLEAN="group group ..."
CLEAN_GROUPS=\
	yocto \
	yocto-dl \
	nand \

CLEAN_yocto=\
	$(YOCTO_BB) \

CLEAN_yocto-dl=\
	$(YOCTO_BB)/downloads \

CLEAN_nand=\
	$(PROF_BLD)/hpps/*.nand.bin \

# Construct a reg exp that will match any ancestor of the given path
ancestor-re-f=$(if $(word 2,$(1)),$(firstword $(1))\($$\|/$(call \
		ancestor-re-f,$(wordlist 2,$(words $(1)),$(1)))\),$(firstword $(1)))
ancestor-re=$(call ancestor-re-f,$(subst /, ,$(1)))

# To guard costly artifacts, exclude paths in groups not given in CLEAN variable
LOCKED_PATHS=$(foreach g,$(filter-out $(CLEAN),$(CLEAN_GROUPS)),$(foreach p,$(CLEAN_$(g)),$(p)))

$(PROF_BLD)/clean:
	@echo -e ' $@:   locked clean groups: $(filter-out $(CLEAN),$(CLEAN_GROUPS))\n' \
			  '$@: unlocked clean groups: $(filter $(CLEAN),$(CLEAN_GROUPS))\n' \
			  '$@: to unlock set CLEAN="group..." (also supports % wildcard)'
	[ ! -d $(@D) ] || \
		find "$(@D)" \
			\( \( -false $(foreach p,$(LOCKED_PATHS),\$(NL) -o -path '$(p)') \) \
				-printf '$@: path locked (to remove add its group to CLEAN): %p\n' \
				-prune \) \
			-o \( -false \
				$(foreach p,$(LOCKED_PATHS),\$(NL) -o -regex '$(call ancestor-re,$(p))') \
				$(foreach p,$(sort $(KEEP_DIRS)),-o -path '$(p)') \) \
			-o -prune -printf 'rm -rf %p\n' -exec rm -rf {} \;

$(PROF_RUN)/clean $(PROF_BLD)/run:  | $(PROF_RUN)/
	find "$(PROF_RUN)" -mindepth 2 -delete
.PHONY: $(PROF_RUN)/clean

$(PROF_PROF)/clean:
	rm -rf "$(PROF_PROF)"

endif # PROF defined

# For declaring pattern rules phony (basically an indirection)

PHONY:
.PHONY: PHONY

define NL


endef

MAKEFLAGS += --no-builtin-rules
